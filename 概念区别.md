###关键概念区别

####抽象类与接口

区别 | 抽象类 | 接口
------------ | ------------- | ------------
关键字|abstract  class  | interface
概念 | 不能实例化的类，可能包含抽象方法 | 抽象方法和静态常量的集合
组成 | 抽象方法、普通方法、静态方法、变量、常量、静态变量、构造方法 | 抽象方法、静态常量
子类 |子类继承抽象类| 实现类实现接口
继承或实现关键字|extends|implements
局限性|单继承，可以多层继承 |没有限制
关系 | 抽象类可以实现接口|接口不能继承抽象类
应用类 |父类强制子类完成某些特定的功能，当然父类中也包含了共同的代码 |约定、规范。 方法的描述，子类必须完成所有的方法

####重写与重载

区别|重写|重载
----|-----|-----
关键词|override|overload
概念|子类重写父类的方法|一个方法的多种展现形式
环境|子类和父类|一个类中
方法名|相同|相同
参数列表|相同|必须不同
返回值|相同|没有要求
访问权限|子类不能比父类更加严格|没有要求
异常|子类不能抛出比父类大的异常|没有要求

-----

####this与super
总结：**this是当前对象在堆空间的引用地址,super是当前对象的父类特征的引用**


super 只是记录对象内部的父类的特征(属性和方法)的一个引用 
>这儿**super不是指向父类对象的引用地址**,new出来的才在堆里面分配空间有引用地址,这儿没有去new一个父类对象,只是执行了父类的构造函数将父类的特征生成了,但是属于New出来的那个子类对象的

实践一下,你可以写 

    public FatherClass getThis() 
    { 
    return this; 
    } 

编译通过,没有任何问题 
但是你写 

    public FatherClass getSuper() 
    { 
    return super; 
    } 
    
嘿嘿,编译出错! 为什么啦？
 
- 因为super并不是一个堆空间里面的一个对象的引用地址,而this才是堆空间里面的一个对象的引用地址 
- super只能在对象内部使用,而this可以在对象内部使用也可以返回出对象外. 
- super是死的,编译的时候就定死了super的指向了,而this是活的,在运行时候决定其指向. 

解释一下:
>子类实例化对象,并没有去实例化他的父类对象,也就是说,那个子类对象里面并没有一个父类对象,那你说没有父类对象,为什么子类构造函数要执行父类的构造函数啦,那是因为需要创建父类的特征赋予子类,但是是由子类所有,而super就是用来区别是是否是父类对象的特征的. 
重写父类方法属性,就是再创建了一个子类的特征,当你用this的时候,就覆盖了父类的特征了,但是父类特征还在那儿,用super就能访问到,但是只能在对象的内部使用.对象外面就只能看到覆盖了父类特征的子类特征了.


区别|this|super
----|----|----
访问属性|this.属性名。只能访问当前对象所拥有的属性(包括继承来的属性，如果继承的属性名和子类对象相同，若不指定则调用子类的，调用父类的需要显示指定：super.属性名)|super.属性名。可以访问父类非私有的属性
访问方法|与访问属性类似|与访问属性类似
调用构造器|this(有参或无参)调用本类中有参或无参的构造函数，必须放在构造函数的第一句|super(有参还是无参)调用父类的有参或是无参的构造方法，必须放在构造方法的第一行（注意：**在同一个构造函数里不能同时出现this()和super()**）
指代|this是当前对象在堆空间的引用地址|super是当前对象的父类特征的引用
作为参数|this可以作为参数，它代表了当前对象的引用|super不可以
使用环境|不可以在static环境中使用|不可以在static环境中使用


-----






